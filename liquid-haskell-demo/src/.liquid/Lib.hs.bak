{-# OPTIONS_GHC -fplugin=LiquidHaskell #-}

module Lib (demo) where

-- (1) pre and post-conditions for functions
-- predicates are from a sublanguage!

{-@ increment :: {v:Int | v >= 0} -> {x:Int | x > 0} @-}
increment :: Int -> Int
increment x = x + 1

{-@ safeDivide :: Int -> {v:Int | v /= 0} -> Int @-}
safeDivide :: Int -> Int -> Int
safeDivide x y = x `div` y

-- (2) refinement types

{-@ type Pos = {v:Int | v > 0} @-}

{-@ posMul :: Pos -> Pos -> Pos @-}
posMul :: Int -> Int -> Int
posMul x y = x * y

-- (3) parametrized refinements

{-@ type BoundedInt Lo Hi = {v:Int | Lo <= v && v <= Hi} @-}

{-@ type ListN a N = {v:[a] | len v == N} @-}

{-@ percentage :: BoundedInt 0 100 -> Double @-}
percentage :: Int -> Double
percentage x = fromIntegral x / 100.0

{-@ sumNonEmpty :: ListN Int 10 -> Int @-}
sumNonEmpty :: [Int] -> Int
sumNonEmpty = sum

-- (4) dependent refinements

-- helper function for demonstration
demo :: IO ()
demo = do
  putStrLn "=== Demo 1: Pre/Post Conditions ==="
  print (increment (-10))              -- Valid: 5 >= 0
  print (safeDivide 10 2)       -- Valid: 2 /= 0

  putStrLn "\n=== Demo 2: Parametrized Refinements ==="
  print (percentage 85)         -- Valid: 0 <= 85 <= 100
  print (sumNonEmpty [1,2,3])   -- Valid: non-empty list
